---
description: Ayame Chamber ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ãƒ»å“è³ªä¿è¨¼æ¨™æº– - Jestãƒ»QC1-4çµ±åˆãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
globs: ["**/*.test.ts", "**/*.spec.ts", "src/**/*.ts"]
alwaysApply: false
dependencies:
  - aidd-cycle.mdc      # AIDDã‚µã‚¤ã‚¯ãƒ«ã«ä¾å­˜ï¼ˆå“è³ªè©•ä¾¡ãƒ—ãƒ­ã‚»ã‚¹ï¼‰
  - git-workflow.mdc    # Gité‹ç”¨ãƒ«ãƒ¼ãƒ«ã«ä¾å­˜ï¼ˆã‚³ãƒŸãƒƒãƒˆç®¡ç†ï¼‰
category: quality
priority: HIGH
---
ã¾ãšã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ãŸã‚‰ã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç™ºè¨€ã™ã‚‹ã“ã¨

# Ayame Chamber ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ãƒ»å“è³ªä¿è¨¼æ¨™æº–

## ğŸ§ª Jestå˜ä½“ãƒ†ã‚¹ãƒˆæ¨™æº–

### åŸºæœ¬ãƒ†ã‚¹ãƒˆæ§‹æˆ
```typescript
import { BaseAgent } from '../agents/base-agent';
import { QualityController } from '../core/qc-gateway';

describe('BaseAgent', () => {
  let agent: BaseAgent;
  let mockQualityController: jest.Mocked<QualityController>;
  
  beforeEach(() => {
    mockQualityController = {
      performQC1Assessment: jest.fn(),
      performQC2Assessment: jest.fn(), 
      performQC3Assessment: jest.fn(),
      performQC4Assessment: jest.fn()
    } as any;
    
    agent = new BaseAgent();
    agent.qualityController = mockQualityController;
  });
  
  afterEach(() => {
    jest.clearAllMocks();
  });
  
  describe('executeTask', () => {
    it('should execute task successfully with quality check', async () => {
      // Arrange
      const input = { query: 'test query', context: 'test context' };
      const expectedOutput = { result: 'test result', confidence: 0.9 };
      
      mockQualityController.performQC1Assessment.mockResolvedValue(8);
      mockQualityController.performQC2Assessment.mockResolvedValue(7);
      mockQualityController.performQC3Assessment.mockResolvedValue(6);
      mockQualityController.performQC4Assessment.mockResolvedValue(5);
      
      // Act
      const result = await agent.executeTask(input);
      
      // Assert
      expect(result).toBeDefined();
      expect(mockQualityController.performQC1Assessment).toHaveBeenCalledWith(input);
      expect(result.qualityScore.totalScore).toBe(26); // 8+7+6+5
    });
    
    it('should handle low quality score appropriately', async () => {
      // å“è³ªã‚¹ã‚³ã‚¢ä¸è¶³ã®ãƒ†ã‚¹ãƒˆ
      mockQualityController.performQC1Assessment.mockResolvedValue(2);
      mockQualityController.performQC2Assessment.mockResolvedValue(3);
      mockQualityController.performQC3Assessment.mockResolvedValue(4);
      mockQualityController.performQC4Assessment.mockResolvedValue(5);
      
      const input = { query: 'poor quality input' };
      const result = await agent.executeTask(input);
      
      expect(result.qualityScore.totalScore).toBe(14); // 15æœªæº€ã§å“è³ªä¸è¶³
      expect(result.requiresImprovement).toBe(true);
    });
  });
});
```

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¥ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³
```typescript
// ãƒªã‚µãƒ¼ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ†ã‚¹ãƒˆä¾‹
describe('WebResearchAgent', () => {
  let webAgent: WebResearchAgent;
  let mockWebClient: jest.Mocked<WebClient>;
  
  beforeEach(() => {
    mockWebClient = {
      search: jest.fn(),
      fetchContent: jest.fn()
    } as any;
    
    webAgent = new WebResearchAgent();
    webAgent.webClient = mockWebClient;
  });
  
  describe('research', () => {
    it('should perform web research with API rate limiting', async () => {
      // APIåˆ¶é™ãƒ†ã‚¹ãƒˆ
      mockWebClient.search.mockResolvedValue([
        { url: 'https://example.com', title: 'Test Article' }
      ]);
      
      const query = 'AI development trends 2025';
      const result = await webAgent.research(query);
      
      expect(mockWebClient.search).toHaveBeenCalledWith(query);
      expect(result.sources).toHaveLength(1);
      expect(result.rateLimitCompliant).toBe(true);
    });
    
    it('should handle API errors gracefully', async () => {
      mockWebClient.search.mockRejectedValue(new Error('API rate limit exceeded'));
      
      const query = 'test query';
      const result = await webAgent.research(query);
      
      expect(result.error).toBeDefined();
      expect(result.fallbackStrategy).toBe('cached_results');
    });
  });
});
```

## ğŸ”— QC1-4å“è³ªè©•ä¾¡çµ±åˆãƒ†ã‚¹ãƒˆ

### å“è³ªè©•ä¾¡ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ
```typescript
describe('QC1-4 Quality Assessment Integration', () => {
  let qualityGateway: QCGateway;
  
  beforeEach(() => {
    qualityGateway = new QCGateway();
  });
  
  describe('QC1: Information Accuracy', () => {
    it('should assess factual accuracy correctly', async () => {
      const testData = {
        content: 'Tokyo is the capital of Japan',
        sources: ['reliable-source.com'],
        factChecked: true
      };
      
      const qc1Score = await qualityGateway.performQC1Assessment(testData);
      
      expect(qc1Score).toBeGreaterThanOrEqual(8); // é«˜ã„æ­£ç¢ºæ€§
      expect(qc1Score).toBeLessThanOrEqual(10);
    });
    
    it('should detect inaccurate information', async () => {
      const testData = {
        content: 'Paris is the capital of Germany',
        sources: ['questionable-source.com'],
        factChecked: false
      };
      
      const qc1Score = await qualityGateway.performQC1Assessment(testData);
      
      expect(qc1Score).toBeLessThanOrEqual(3); // ä½ã„æ­£ç¢ºæ€§
    });
  });
  
  describe('QC2: Relevance', () => {
    it('should assess query relevance accurately', async () => {
      const query = 'AI development tools';
      const response = 'Here are the top AI development frameworks: TensorFlow, PyTorch...';
      
      const qc2Score = await qualityGateway.performQC2Assessment(query, response);
      
      expect(qc2Score).toBeGreaterThanOrEqual(7);
    });
  });
  
  describe('QC3: Completeness', () => {
    it('should evaluate response completeness', async () => {
      const requirements = ['introduction', 'main_points', 'conclusion', 'sources'];
      const response = {
        introduction: 'Present',
        main_points: ['Point 1', 'Point 2', 'Point 3'],
        conclusion: 'Present', 
        sources: ['Source 1', 'Source 2']
      };
      
      const qc3Score = await qualityGateway.performQC3Assessment(requirements, response);
      
      expect(qc3Score).toBe(8); // å…¨è¦ç´ å®Œå‚™
    });
  });
  
  describe('QC4: Usefulness', () => {
    it('should assess practical usefulness', async () => {
      const context = 'software development project';
      const response = 'Step-by-step implementation guide with code examples';
      
      const qc4Score = await qualityGateway.performQC4Assessment(context, response);
      
      expect(qc4Score).toBeGreaterThanOrEqual(6);
    });
  });
});
```

## ğŸ¤– ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±åˆãƒ†ã‚¹ãƒˆ

### 56ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä½“åˆ¶ãƒ†ã‚¹ãƒˆ
```typescript
describe('Agent Integration Tests', () => {
  let orchestrator: Orchestrator;
  let routerAgent: BaseRouterAgent;
  
  beforeEach(async () => {
    orchestrator = new Orchestrator();
    routerAgent = new BaseRouterAgent();
    await orchestrator.initialize();
  });
  
  describe('Multi-Agent Workflow', () => {
    it('should execute research -> planning -> implementation workflow', async () => {
      const task = {
        type: 'full_development_cycle',
        description: 'Create a new AI feature',
        requirements: ['research', 'planning', 'implementation']
      };
      
      // ç ”ç©¶ãƒ•ã‚§ãƒ¼ã‚º
      const researchResult = await orchestrator.executeAgent('WebResearchAgent', {
        query: 'AI feature implementation best practices'
      });
      
      // ä¼ç”»ãƒ•ã‚§ãƒ¼ã‚º  
      const planningResult = await orchestrator.executeAgent('PlanningAgent', {
        researchData: researchResult,
        requirements: task.requirements
      });
      
      // å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º
      const implementationResult = await orchestrator.executeAgent('CodeImplementationAgent', {
        plan: planningResult,
        specifications: planningResult.specifications
      });
      
      expect(researchResult.qualityScore.totalScore).toBeGreaterThanOrEqual(15);
      expect(planningResult.qualityScore.totalScore).toBeGreaterThanOrEqual(15);  
      expect(implementationResult.qualityScore.totalScore).toBeGreaterThanOrEqual(15);
      expect(implementationResult.code).toBeDefined();
    });
  });
  
  describe('Error Propagation & Recovery', () => {
    it('should handle agent failures gracefully', async () => {
      // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆéšœå®³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
      const mockFailingAgent = jest.fn().mockRejectedValue(new Error('Agent failure'));
      orchestrator.registerAgent('FailingAgent', mockFailingAgent);
      
      const result = await orchestrator.executeAgent('FailingAgent', { test: true });
      
      expect(result.error).toBeDefined();
      expect(result.recoveryAction).toBe('fallback_agent_used');
      expect(result.fallbackResult).toBeDefined();
    });
  });
});
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

### è² è·ãƒ†ã‚¹ãƒˆãƒ»åŒæ™‚å®Ÿè¡Œãƒ†ã‚¹ãƒˆ
```typescript
describe('Performance Tests', () => {
  describe('Concurrent Agent Execution', () => {
    it('should handle multiple agents concurrently without degradation', async () => {
      const concurrentTasks = Array.from({ length: 10 }, (_, i) => ({
        agentName: `TestAgent${i}`,
        task: async () => {
          await new Promise(resolve => setTimeout(resolve, 100)); // 100mså‡¦ç†
          return { result: `Result ${i}`, executionTime: 100 };
        }
      }));
      
      const startTime = Date.now();
      const results = await Promise.all(
        concurrentTasks.map(task => orchestrator.executeAgent(task.agentName, task.task))
      );
      const totalTime = Date.now() - startTime;
      
      // ä¸¦è¡Œå®Ÿè¡Œã«ã‚ˆã‚Šç·æ™‚é–“ã¯å¤§å¹…çŸ­ç¸®ã•ã‚Œã‚‹ã¹ã
      expect(totalTime).toBeLessThan(500); // 1000msã‚ˆã‚Šå¤§å¹…ã«çŸ­ã„
      expect(results).toHaveLength(10);
      results.forEach(result => {
        expect(result.error).toBeUndefined();
      });
    });
  });
  
  describe('Memory Usage', () => {
    it('should maintain stable memory usage during long operations', async () => {
      const initialMemory = process.memoryUsage().heapUsed;
      
      // é•·æ™‚é–“å®Ÿè¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
      for (let i = 0; i < 100; i++) {
        await orchestrator.executeAgent('MemoryTestAgent', {
          data: Array.from({ length: 1000 }, (_, j) => `data-${j}`)
        });
      }
      
      // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
      if (global.gc) global.gc();
      
      const finalMemory = process.memoryUsage().heapUsed;
      const memoryIncrease = finalMemory - initialMemory;
      
      // ãƒ¡ãƒ¢ãƒªå¢—åŠ ã¯10MBä»¥ä¸‹ã§ã‚ã‚‹ã¹ã
      expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
    });
  });
});
```

## ğŸ—„ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ»APIçµ±åˆãƒ†ã‚¹ãƒˆ  

### ChromaDBãƒ»Notion API ãƒ†ã‚¹ãƒˆ
```typescript
describe('Database Integration Tests', () => {
  describe('ChromaDB Integration', () => {
    let chromaClient: ChromaDB;
    
    beforeEach(async () => {
      chromaClient = new ChromaDB();
      await chromaClient.initialize();
    });
    
    afterEach(async () => {
      await chromaClient.cleanup();
    });
    
    it('should perform vector search efficiently', async () => {
      // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿æŒ¿å…¥
      await chromaClient.collection.add({
        documents: ['AI development', 'Machine learning', 'Neural networks'],
        ids: ['doc1', 'doc2', 'doc3']
      });
      
      const startTime = Date.now();
      const results = await chromaClient.search('artificial intelligence', 2);
      const searchTime = Date.now() - startTime;
      
      expect(results).toBeDefined();
      expect(results.length).toBeLessThanOrEqual(2);
      expect(searchTime).toBeLessThan(1000); // 1ç§’ä»¥å†…
    });
  });
  
  describe('Notion API Integration', () => {
    let notionService: NotionService;
    
    beforeEach(() => {
      notionService = new NotionService();
    });
    
    it('should respect API rate limits', async () => {
      const requests = Array.from({ length: 5 }, (_, i) => 
        notionService.createPage('test-database-id', {
          title: { title: [{ text: { content: `Test Page ${i}` } }] }
        })
      );
      
      const startTime = Date.now();
      await Promise.all(requests);
      const totalTime = Date.now() - startTime;
      
      // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«ã‚ˆã‚Šæœ€ä½é™ã®æ™‚é–“ãŒã‹ã‹ã‚‹ã¯ãš
      expect(totalTime).toBeGreaterThan(1000); // 1ç§’ä»¥ä¸Š
    });
  });
});
```

## ğŸ” å“è³ªå›å¸°ãƒ†ã‚¹ãƒˆ

### è‡ªå‹•å“è³ªå›å¸°æ¤œå‡º
```typescript
describe('Quality Regression Tests', () => {
  const baselineScores = {
    WebResearchAgent: { qc1: 8, qc2: 7, qc3: 6, qc4: 6 },
    PlanningAgent: { qc1: 7, qc2: 8, qc3: 7, qc4: 7 },
    MarketingAgent: { qc1: 6, qc2: 8, qc3: 6, qc4: 8 }
  };
  
  Object.entries(baselineScores).forEach(([agentName, baseline]) => {
    describe(agentName, () => {
      it('should maintain quality score baseline', async () => {
        const agent = orchestrator.getAgent(agentName);
        const testInput = getStandardTestInput(agentName);
        
        const result = await agent.executeTask(testInput);
        const scores = result.qualityScore;
        
        expect(scores.qc1Score).toBeGreaterThanOrEqual(baseline.qc1 - 1); // -1ã®è¨±å®¹å·®
        expect(scores.qc2Score).toBeGreaterThanOrEqual(baseline.qc2 - 1);
        expect(scores.qc3Score).toBeGreaterThanOrEqual(baseline.qc3 - 1);
        expect(scores.qc4Score).toBeGreaterThanOrEqual(baseline.qc4 - 1);
      });
    });
  });
});
```

## ğŸ“ˆ ç¶™ç¶šçš„å“è³ªç›£è¦–

### è‡ªå‹•ãƒ†ã‚¹ãƒˆå®Ÿè¡Œãƒ»ãƒ¬ãƒãƒ¼ãƒˆ
```typescript
class QualityMonitor {
  async runDailyQualityCheck(): Promise<QualityReport> {
    const report: QualityReport = {
      date: new Date(),
      agentScores: new Map(),
      overallHealth: 'UNKNOWN',
      issues: []
    };
    
    // å…¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å“è³ªãƒã‚§ãƒƒã‚¯
    for (const agentName of this.getAllAgentNames()) {
      try {
        const score = await this.runAgentQualityTest(agentName);
        report.agentScores.set(agentName, score);
        
        if (score.totalScore < 15) {
          report.issues.push({
            agent: agentName,
            issue: 'Quality score below threshold',
            severity: 'HIGH'
          });
        }
      } catch (error) {
        report.issues.push({
          agent: agentName,
          issue: `Test execution failed: ${error.message}`,
          severity: 'CRITICAL'
        });
      }
    }
    
    // å…¨ä½“å¥å…¨æ€§è©•ä¾¡
    report.overallHealth = this.calculateOverallHealth(report);
    
    // ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜ãƒ»é€šçŸ¥
    await this.saveQualityReport(report);
    if (report.overallHealth === 'POOR') {
      await this.sendQualityAlert(report);
    }
    
    return report;
  }
}
```

---

**é‡è¦**: ãƒ†ã‚¹ãƒˆã¯é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã®æ ¸å¿ƒã§ã™ã€‚ã™ã¹ã¦ã®æ–°æ©Ÿèƒ½ãƒ»å¤‰æ›´ã«å¯¾ã—ã¦é©åˆ‡ãªãƒ†ã‚¹ãƒˆã‚’ä½œæˆã—ã€å“è³ªå›å¸°ã‚’é˜²ããŸã‚ç¶™ç¶šçš„ã«å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚