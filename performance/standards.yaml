---
description: Ayame Chamber ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æ¨™æº– - ãƒ¡ãƒ¢ãƒªãƒ»CPUãƒ»DBåŠ¹ç‡åŒ–
globs: ["src/**/*.ts", "webui/**/*.tsx"]
alwaysApply: true  
---
ã¾ãšã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ãŸã‚‰ã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç™ºè¨€ã™ã‚‹ã“ã¨

# Ayame Chamber ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æ¨™æº–

## ğŸ’¾ ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–ãƒ»ç®¡ç†

### éšå±¤è¨˜æ†¶ã‚·ã‚¹ãƒ†ãƒ æœ€é©åŒ–
```typescript
class MemoryOptimizer {
  private memoryThresholds = {
    working: 100 * 1024 * 1024,    // 100MB - Working Memory
    episodic: 500 * 1024 * 1024,  // 500MB - Episodic Memory  
    semantic: 200 * 1024 * 1024,  // 200MB - Semantic Memory
    procedural: 50 * 1024 * 1024  // 50MB - Procedural Memory
  };
  
  async monitorMemoryUsage(): Promise<MemoryReport> {
    const usage = process.memoryUsage();
    const heapUsed = usage.heapUsed;
    const heapTotal = usage.heapTotal;
    const external = usage.external;
    
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡è¨ˆç®—
    const usageRatio = heapUsed / heapTotal;
    
    if (usageRatio > 0.8) {
      await this.triggerGarbageCollection();
    }
    
    return {
      heapUsed: Math.round(heapUsed / 1024 / 1024), // MB
      heapTotal: Math.round(heapTotal / 1024 / 1024),
      external: Math.round(external / 1024 / 1024),
      usageRatio: usageRatio,
      recommendation: this.getOptimizationRecommendation(usageRatio)
    };
  }
  
  private async triggerGarbageCollection(): Promise<void> {
    if (global.gc) {
      logger.warn('High memory usage detected, triggering GC');
      global.gc();
    }
  }
}
```

### Working MemoryåŠ¹ç‡ç®¡ç†
```typescript
class WorkingMemoryManager {
  private sessionMemory: Map<string, any> = new Map();
  private maxSessions = 100;
  private sessionTimeout = 30 * 60 * 1000; // 30åˆ†
  
  async optimizeWorkingMemory(): Promise<void> {
    const now = Date.now();
    let cleanedCount = 0;
    
    // å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³å‰Šé™¤
    for (const [sessionId, data] of this.sessionMemory) {
      if (now - data.lastAccess > this.sessionTimeout) {
        this.sessionMemory.delete(sessionId);
        cleanedCount++;
      }
    }
    
    // å®¹é‡è¶…éæ™‚ã®LRUå‰Šé™¤
    if (this.sessionMemory.size > this.maxSessions) {
      const sortedSessions = Array.from(this.sessionMemory.entries())
        .sort((a, b) => a[1].lastAccess - b[1].lastAccess);
        
      const toDelete = sortedSessions.slice(0, this.sessionMemory.size - this.maxSessions);
      toDelete.forEach(([sessionId]) => this.sessionMemory.delete(sessionId));
      cleanedCount += toDelete.length;
    }
    
    if (cleanedCount > 0) {
      logger.info('Working memory optimized', { cleanedSessions: cleanedCount });
    }
  }
}
```

## âš¡ CPUåŠ¹ç‡åŒ–ãƒ»ä¸¦è¡Œå‡¦ç†

### Agentä¸¦è¡Œå®Ÿè¡Œç®¡ç†  
```typescript
class ConcurrencyManager {
  private maxConcurrentAgents = 5;  // åŒæ™‚å®Ÿè¡Œæœ€å¤§æ•°
  private runningAgents: Set<string> = new Set();
  private agentQueue: Array<{agent: string, task: () => Promise<any>}> = [];
  
  async executeAgent(agentName: string, task: () => Promise<any>): Promise<any> {
    // åŒæ™‚å®Ÿè¡Œåˆ¶é™ãƒã‚§ãƒƒã‚¯
    if (this.runningAgents.size >= this.maxConcurrentAgents) {
      return this.queueAgent(agentName, task);
    }
    
    return this.runAgent(agentName, task);
  }
  
  private async runAgent(agentName: string, task: () => Promise<any>): Promise<any> {
    const startTime = Date.now();
    this.runningAgents.add(agentName);
    
    try {
      const result = await task();
      
      // CPUä½¿ç”¨æ™‚é–“è¨˜éŒ²
      const executionTime = Date.now() - startTime;
      await this.logPerformanceMetrics(agentName, executionTime);
      
      return result;
    } finally {
      this.runningAgents.delete(agentName);
      
      // ã‚­ãƒ¥ãƒ¼ã‹ã‚‰æ¬¡ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œ
      await this.processQueue();
    }
  }
  
  private async processQueue(): Promise<void> {
    if (this.agentQueue.length > 0 && this.runningAgents.size < this.maxConcurrentAgents) {
      const next = this.agentQueue.shift()!;
      setImmediate(() => this.runAgent(next.agent, next.task));
    }
  }
}
```

### éåŒæœŸå‡¦ç†æœ€é©åŒ–
```typescript
class AsyncOptimizer {
  // Promise.all ã«ã‚ˆã‚‹ä¸¦è¡Œå‡¦ç†
  static async parallelExecution<T>(tasks: (() => Promise<T>)[]): Promise<T[]> {
    const batchSize = 3; // ä¸¦è¡Œå®Ÿè¡Œæ•°åˆ¶é™
    const results: T[] = [];
    
    for (let i = 0; i < tasks.length; i += batchSize) {
      const batch = tasks.slice(i, i + batchSize);
      const batchResults = await Promise.all(batch.map(task => task()));
      results.push(...batchResults);
    }
    
    return results;
  }
  
  // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãå®Ÿè¡Œ
  static async withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
    const timeoutPromise = new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error('Operation timed out')), timeoutMs)
    );
    
    return Promise.race([promise, timeoutPromise]);
  }
}
```

## ğŸ—„ï¸ ChromaDBæœ€é©åŒ–

### ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢åŠ¹ç‡åŒ–
```typescript
class ChromaDBOptimizer {
  private chromaClient: any;
  private queryCache: Map<string, any> = new Map();
  private cacheTimeout = 10 * 60 * 1000; // 10åˆ†ã‚­ãƒ£ãƒƒã‚·ãƒ¥
  
  async optimizedVectorSearch(
    query: string, 
    collection: string,
    limit: number = 10
  ): Promise<any> {
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
    const cacheKey = `${collection}:${query}:${limit}`;
    const cached = this.queryCache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      logger.debug('ChromaDB query cache hit', { cacheKey });
      return cached.result;
    }
    
    // ãƒãƒƒãƒå‡¦ç†ã§Embeddingç”Ÿæˆ
    const embeddings = await this.generateEmbeddingsBatch([query]);
    
    const result = await this.chromaClient.query({
      collectionName: collection,
      queryEmbeddings: embeddings,
      n_results: limit
    });
    
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
    this.queryCache.set(cacheKey, {
      result: result,
      timestamp: Date.now()
    });
    
    return result;
  }
  
  private async generateEmbeddingsBatch(texts: string[]): Promise<number[][]> {
    // ãƒãƒƒãƒã‚µã‚¤ã‚ºåˆ¶é™ã§APIåŠ¹ç‡åŒ–
    const batchSize = 100;
    const results: number[][] = [];
    
    for (let i = 0; i < texts.length; i += batchSize) {
      const batch = texts.slice(i, i + batchSize);
      const batchEmbeddings = await this.callEmbeddingAPI(batch);
      results.push(...batchEmbeddings);
    }
    
    return results;
  }
}
```

### ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æœ€é©åŒ–
```typescript
class ChromaIndexOptimizer {
  async optimizeCollectionIndex(collectionName: string): Promise<void> {
    // å®šæœŸçš„ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å†æ§‹ç¯‰
    const stats = await this.getCollectionStats(collectionName);
    
    if (stats.documentCount > 10000 && stats.lastOptimized < Date.now() - 24 * 60 * 60 * 1000) {
      logger.info('Starting ChromaDB index optimization', { collection: collectionName });
      
      await this.chromaClient.optimizeCollection({
        collection_name: collectionName
      });
      
      logger.info('ChromaDB index optimization completed', { collection: collectionName });
    }
  }
}
```

## ğŸ“Š Notion APIæœ€é©åŒ–

### ãƒãƒƒãƒå‡¦ç†ãƒ»ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³
```typescript
class NotionOptimizer {
  private notion: any;
  private requestQueue: any[] = [];
  private processingBatch = false;
  
  async optimizedPageQuery(
    databaseId: string, 
    filters?: any
  ): Promise<any[]> {
    const allResults: any[] = [];
    let startCursor: string | undefined;
    
    do {
      const response = await this.notion.databases.query({
        database_id: databaseId,
        filter: filters,
        start_cursor: startCursor,
        page_size: 100  // æœ€å¤§ãƒšãƒ¼ã‚¸ã‚µã‚¤ã‚º
      });
      
      allResults.push(...response.results);
      startCursor = response.next_cursor;
      
      // APIåˆ¶é™ã«é…æ…®ã—ãŸé…å»¶
      await this.respectRateLimit();
      
    } while (startCursor);
    
    return allResults;
  }
  
  // ãƒãƒƒãƒãƒ©ã‚¤ãƒˆå‡¦ç†
  async batchUpdate(updates: Array<{pageId: string, properties: any}>): Promise<void> {
    const batchSize = 10;
    
    for (let i = 0; i < updates.length; i += batchSize) {
      const batch = updates.slice(i, i + batchSize);
      
      await Promise.all(batch.map(async (update) => {
        await this.notion.pages.update({
          page_id: update.pageId,
          properties: update.properties
        });
      }));
      
      await this.respectRateLimit();
    }
  }
  
  private async respectRateLimit(): Promise<void> {
    // Notion API: 3 requests per second
    await new Promise(resolve => setTimeout(resolve, 350));
  }
}
```

## ğŸ” ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

### ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
```typescript
class PerformanceMonitor {
  private metricsHistory: PerformanceMetric[] = [];
  
  async collectSystemMetrics(): Promise<SystemMetrics> {
    const cpuUsage = process.cpuUsage();
    const memoryUsage = process.memoryUsage();
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—é…å»¶æ¸¬å®š
    const eventLoopDelay = await this.measureEventLoopDelay();
    
    const metrics = {
      timestamp: new Date(),
      cpu: {
        user: cpuUsage.user / 1000, // microseconds to milliseconds
        system: cpuUsage.system / 1000
      },
      memory: {
        heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024),
        heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024),
        external: Math.round(memoryUsage.external / 1024 / 1024)
      },
      eventLoopDelay: eventLoopDelay,
      activeConnections: this.getActiveConnectionCount()
    };
    
    this.metricsHistory.push(metrics);
    
    // å±¥æ­´ã‚µã‚¤ã‚ºåˆ¶é™
    if (this.metricsHistory.length > 1000) {
      this.metricsHistory = this.metricsHistory.slice(-1000);
    }
    
    // ç•°å¸¸å€¤æ¤œå‡º
    await this.detectPerformanceAnomalies(metrics);
    
    return metrics;
  }
  
  private async detectPerformanceAnomalies(current: SystemMetrics): Promise<void> {
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡è­¦å‘Š
    if (current.memory.heapUsed > 1000) { // 1GB
      logger.warn('High memory usage detected', { 
        heapUsed: current.memory.heapUsed 
      });
    }
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—é…å»¶è­¦å‘Š  
    if (current.eventLoopDelay > 100) { // 100ms
      logger.warn('High event loop delay detected', { 
        delay: current.eventLoopDelay 
      });
    }
  }
}
```

### è‡ªå‹•æœ€é©åŒ–å®Ÿè¡Œ
```typescript
class AutoOptimizer {
  private optimizationInterval = 15 * 60 * 1000; // 15åˆ†é–“éš”
  
  startAutoOptimization(): void {
    setInterval(async () => {
      await this.runOptimizationCycle();
    }, this.optimizationInterval);
  }
  
  private async runOptimizationCycle(): Promise<void> {
    logger.info('Starting automatic optimization cycle');
    
    try {
      // 1. ãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      await this.memoryOptimizer.optimizeWorkingMemory();
      
      // 2. ChromaDBã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æœ€é©åŒ–
      await this.chromaOptimizer.optimizeAllCollections();
      
      // 3. ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—  
      await this.clearExpiredCaches();
      
      // 4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
      const metrics = await this.performanceMonitor.collectSystemMetrics();
      
      logger.info('Optimization cycle completed', { metrics });
      
    } catch (error) {
      logger.error('Optimization cycle failed', { error: error.message });
    }
  }
}
```

---

**é‡è¦**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã¯ç¶™ç¶šçš„ãªãƒ—ãƒ­ã‚»ã‚¹ã§ã™ã€‚å®šæœŸçš„ãªç›£è¦–ã¨ãƒ¡ãƒˆãƒªã‚¯ã‚¹åˆ†æã‚’é€šã˜ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã®å¥å…¨æ€§ã‚’ç¶­æŒã—ã¦ãã ã•ã„ã€‚