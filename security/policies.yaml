---
description: Ayame Chamber ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ - å˜ä¸€ãƒ¦ãƒ¼ã‚¶ãƒ¼ç’°å¢ƒç‰¹åŒ–å‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
globs: ["**/*.ts", "**/*.js", "**/*.json", ".env*"]
alwaysApply: true
---
ã¾ãšã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ãŸã‚‰ã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç™ºè¨€ã™ã‚‹ã“ã¨

# Ayame Chamber ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## ğŸ” ç’°å¢ƒå¤‰æ•°ãƒ»æ©Ÿå¯†æƒ…å ±ç®¡ç†

### .env ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†æ¨™æº–
```bash
# âœ… å¿…é ˆè¨­å®šä¾‹
OPENAI_API_KEY=sk-xxxxxxxxxxxxxxxxxxxxxxxx
CLAUDE_API_KEY=sk-ant-xxxxxxxxxxxxxxxx  
NOTION_TOKEN=secret_xxxxxxxxxxxxxxxx
SLACK_BOT_TOKEN=xoxb-xxxxxxxxxxxxxxxx
GOOGLE_CALENDAR_CREDENTIALS=./credentials/google-token.json

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
CHROMA_HOST=localhost
CHROMA_PORT=8000
MEMORY_SYSTEM_PATH=./data/memory

# ã‚·ã‚¹ãƒ†ãƒ è¨­å®š  
NODE_ENV=development
LOG_LEVEL=info
MAX_CONCURRENT_AGENTS=5
```

### ç’°å¢ƒå¤‰æ•°æ¤œè¨¼æ©Ÿèƒ½
```typescript
class EnvironmentValidator {
  private static requiredVars = [
    'OPENAI_API_KEY',
    'NOTION_TOKEN', 
    'SLACK_BOT_TOKEN'
  ];
  
  static validateEnvironment(): void {
    const missing: string[] = [];
    
    this.requiredVars.forEach(varName => {
      if (!process.env[varName]) {
        missing.push(varName);
      }
    });
    
    if (missing.length > 0) {
      throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
    }
    
    // API Keyãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¤œè¨¼
    this.validateAPIKeyFormats();
  }
  
  private static validateAPIKeyFormats(): void {
    const openaiKey = process.env.OPENAI_API_KEY;
    if (openaiKey && !openaiKey.startsWith('sk-')) {
      throw new Error('Invalid OpenAI API key format');
    }
    
    const claudeKey = process.env.CLAUDE_API_KEY;
    if (claudeKey && !claudeKey.startsWith('sk-ant-')) {
      throw new Error('Invalid Claude API key format');
    }
  }
}
```

## ğŸ›¡ï¸ API Keyä¿è­·ãƒ»ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³

### æ©Ÿå¯†æƒ…å ±ä¿è­·ã‚¯ãƒ©ã‚¹
```typescript
class SecretManager {
  private static sensitivePatterns = [
    /sk-[a-zA-Z0-9]{48}/, // OpenAI
    /sk-ant-[a-zA-Z0-9-]{95}/, // Claude
    /secret_[a-zA-Z0-9]{43}/, // Notion
    /xoxb-[0-9]+-[0-9]+-[0-9]+-[a-z0-9]{24}/ // Slack
  ];
  
  static sanitizeForLogging(text: string): string {
    let sanitized = text;
    
    this.sensitivePatterns.forEach(pattern => {
      sanitized = sanitized.replace(pattern, '***API_KEY_MASKED***');
    });
    
    return sanitized;
  }
  
  static detectSecretsInCode(content: string): string[] {
    const detectedSecrets: string[] = [];
    
    this.sensitivePatterns.forEach(pattern => {
      const matches = content.match(pattern);
      if (matches) {
        detectedSecrets.push(...matches);
      }
    });
    
    return detectedSecrets;
  }
  
  static validateSecretRotation(): void {
    // API Keyä½œæˆæ—¥æ™‚ãƒã‚§ãƒƒã‚¯ï¼ˆå¯èƒ½ãªå ´åˆï¼‰
    const keyAge = this.getAPIKeyAge(process.env.OPENAI_API_KEY);
    if (keyAge > 90) { // 90æ—¥ä»¥ä¸Š
      logger.warn('API key rotation recommended', { keyAge });
    }
  }
}
```

### ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¿è­·
```typescript
class FileSystemSecurity {
  private static restrictedPaths = [
    '/etc/passwd',
    '/etc/shadow', 
    '/root/',
    process.env.HOME + '/.ssh/',
    './credentials/'
  ];
  
  static validateFilePath(filePath: string): void {
    // çµ¶å¯¾ãƒ‘ã‚¹ãƒ»ç›¸å¯¾ãƒ‘ã‚¹æ­£è¦åŒ–
    const normalizedPath = path.resolve(filePath);
    
    // åˆ¶é™ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒã‚§ãƒƒã‚¯
    this.restrictedPaths.forEach(restricted => {
      if (normalizedPath.startsWith(path.resolve(restricted))) {
        throw new Error(`Access to restricted path denied: ${restricted}`);
      }
    });
    
    // ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«æ”»æ’ƒé˜²æ­¢
    if (filePath.includes('../') || filePath.includes('..\\')) {
      throw new Error('Path traversal attempt detected');
    }
  }
  
  static async secureFileWrite(filePath: string, content: string): Promise<void> {
    this.validateFilePath(filePath);
    
    // æ©Ÿå¯†æƒ…å ±æ¤œå‡º
    const secrets = SecretManager.detectSecretsInCode(content);
    if (secrets.length > 0) {
      throw new Error('Attempted to write secrets to file');
    }
    
    // å®‰å…¨ãªæ›¸ãè¾¼ã¿å®Ÿè¡Œ
    await fs.writeFile(filePath, content, { mode: 0o600 }); // æ‰€æœ‰è€…ã®ã¿èª­ã¿æ›¸ã
  }
}
```

## ğŸ”’ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### HTTPSå¿…é ˆãƒ»è¨¼æ˜æ›¸æ¤œè¨¼
```typescript
import https from 'https';

class SecureHTTPClient {
  private static httpsAgent = new https.Agent({
    rejectUnauthorized: true, // SSLè¨¼æ˜æ›¸æ¤œè¨¼å¿…é ˆ
    minVersion: 'TLSv1.2'    // TLS 1.2ä»¥ä¸Š
  });
  
  static async secureRequest(url: string, options: any = {}): Promise<any> {
    // HTTPSãƒ—ãƒ­ãƒˆã‚³ãƒ«å¼·åˆ¶
    if (!url.startsWith('https://')) {
      throw new Error('Only HTTPS connections allowed');
    }
    
    // ã‚»ã‚­ãƒ¥ã‚¢ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä½¿ç”¨
    options.agent = this.httpsAgent;
    
    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
    options.timeout = options.timeout || 30000; // 30ç§’
    
    return await this.executeSecureRequest(url, options);
  }
  
  private static async executeSecureRequest(url: string, options: any): Promise<any> {
    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆå®Ÿè¡Œæ™‚ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼è¿½åŠ 
    const headers = {
      ...options.headers,
      'User-Agent': 'Ayame-Chamber/1.0.0',
      'X-Requested-With': 'Ayame-Chamber'
    };
    
    return fetch(url, { ...options, headers });
  }
}
```

### IPåˆ¶é™ãƒ»ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡
```typescript
class NetworkAccessControl {
  private static allowedIPs = [
    '127.0.0.1',     // localhost
    '::1',           // localhost IPv6
    '192.168.0.0/16', // ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
    '10.0.0.0/8'     // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
  ];
  
  static validateSourceIP(ip: string): boolean {
    // é–‹ç™ºç’°å¢ƒã§ã¯åˆ¶é™ç·©å’Œ
    if (process.env.NODE_ENV === 'development') {
      return true;
    }
    
    return this.allowedIPs.some(allowed => {
      if (allowed.includes('/')) {
        return this.isIPInCIDR(ip, allowed);
      }
      return ip === allowed;
    });
  }
  
  private static isIPInCIDR(ip: string, cidr: string): boolean {
    // CIDRç¯„å›²ãƒã‚§ãƒƒã‚¯å®Ÿè£…
    // ç°¡ç•¥åŒ– - å®Ÿéš›ã®å®Ÿè£…ã§ã¯é©åˆ‡ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
    return true;
  }
}
```

## ğŸ” å…¥åŠ›æ¤œè¨¼ãƒ»ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³

### ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›æ¤œè¨¼
```typescript
class InputValidator {
  // SQL Injectioné˜²æ­¢ï¼ˆNotion APIã‚¯ã‚¨ãƒªç”¨ï¼‰
  static validateNotionQuery(query: any): any {
    if (typeof query !== 'object' || query === null) {
      throw new Error('Invalid query format');
    }
    
    // å±é™ºãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
    const dangerousKeys = ['$eval', '$where', 'constructor', 'prototype'];
    this.checkDangerousKeys(query, dangerousKeys);
    
    return query;
  }
  
  // XSSé˜²æ­¢ï¼ˆWebUIç”¨ï¼‰
  static sanitizeHTML(input: string): string {
    return input
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
  }
  
  // ã‚³ãƒãƒ³ãƒ‰ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³é˜²æ­¢
  static validateCommand(command: string): string {
    const dangerousCommands = [
      'rm', 'del', 'format', 'sudo', 'su', 
      'chmod', 'chown', 'cat /etc', 'cat ~/.ssh'
    ];
    
    dangerousCommands.forEach(dangerous => {
      if (command.toLowerCase().includes(dangerous)) {
        throw new Error(`Dangerous command detected: ${dangerous}`);
      }
    });
    
    return command;
  }
  
  private static checkDangerousKeys(obj: any, dangerousKeys: string[]): void {
    Object.keys(obj).forEach(key => {
      if (dangerousKeys.includes(key)) {
        throw new Error(`Dangerous property detected: ${key}`);
      }
      
      if (typeof obj[key] === 'object' && obj[key] !== null) {
        this.checkDangerousKeys(obj[key], dangerousKeys);
      }
    });
  }
}
```

## ğŸ“ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°ãƒ»ç›£æŸ»

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆè¨˜éŒ²
```typescript
class SecurityAuditor {
  static async logSecurityEvent(
    eventType: 'AUTH_FAILURE' | 'SUSPICIOUS_ACCESS' | 'SECRET_EXPOSURE' | 'FILE_ACCESS',
    details: any
  ): Promise<void> {
    const securityEvent = {
      timestamp: new Date().toISOString(),
      eventType: eventType,
      severity: this.getSeverity(eventType),
      details: details,
      sourceIP: details.sourceIP || 'unknown',
      userAgent: details.userAgent || 'unknown'
    };
    
    // é«˜é‡è¦åº¦ã‚¤ãƒ™ãƒ³ãƒˆã¯å³åº§é€šçŸ¥
    if (securityEvent.severity === 'HIGH') {
      await this.sendSecurityAlert(securityEvent);
    }
    
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨˜éŒ²
    await this.writeSecurityLog(securityEvent);
  }
  
  private static getSeverity(eventType: string): 'HIGH' | 'MEDIUM' | 'LOW' {
    switch (eventType) {
      case 'SECRET_EXPOSURE':
        return 'HIGH';
      case 'SUSPICIOUS_ACCESS':
        return 'MEDIUM';
      default:
        return 'LOW';
    }
  }
  
  private static async sendSecurityAlert(event: any): Promise<void> {
    // Slacké€šçŸ¥ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒ£ãƒ³ãƒãƒ«ï¼‰
    if (process.env.SECURITY_SLACK_WEBHOOK) {
      await this.sendSlackAlert(event);
    }
  }
}
```

## ğŸ”§ ã‚»ã‚­ãƒ¥ã‚¢ãªé–‹ç™ºå®Ÿè·µ

### ã‚³ãƒ¼ãƒ‰ã‚¹ã‚­ãƒ£ãƒ³ãƒ»è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯
```typescript
class VulnerabilityScanner {
  static async scanCodeForVulnerabilities(filePath: string): Promise<SecurityIssue[]> {
    const content = await fs.readFile(filePath, 'utf-8');
    const issues: SecurityIssue[] = [];
    
    // ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸç§˜å¯†æƒ…å ±æ¤œå‡º
    const secrets = SecretManager.detectSecretsInCode(content);
    secrets.forEach(secret => {
      issues.push({
        type: 'HARDCODED_SECRET',
        severity: 'HIGH',
        line: this.findLineNumber(content, secret),
        description: 'Hardcoded API key detected'
      });
    });
    
    // å±é™ºãªé–¢æ•°ä½¿ç”¨ãƒã‚§ãƒƒã‚¯
    const dangerousFunctions = ['eval', 'Function', 'setTimeout', 'setInterval'];
    dangerousFunctions.forEach(func => {
      if (content.includes(`${func}(`)) {
        issues.push({
          type: 'DANGEROUS_FUNCTION',
          severity: 'MEDIUM', 
          description: `Use of dangerous function: ${func}`
        });
      }
    });
    
    return issues;
  }
}
```

### ä¾å­˜é–¢ä¿‚ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
```typescript
class DependencySecurity {
  static async checkDependencyVulnerabilities(): Promise<void> {
    // package.jsonã‹ã‚‰ä¾å­˜é–¢ä¿‚èª­ã¿å–ã‚Š
    const packageJson = JSON.parse(await fs.readFile('package.json', 'utf-8'));
    const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };
    
    // æ—¢çŸ¥ã®è„†å¼±æ€§ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒã‚§ãƒƒã‚¯
    const vulnerablePackages = [
      'lodash@<4.17.21',
      'axios@<0.21.1'
    ];
    
    Object.keys(dependencies).forEach(pkg => {
      const version = dependencies[pkg];
      this.checkPackageVulnerability(pkg, version);
    });
  }
}
```

---

**é‡è¦**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¯ç¶™ç¶šçš„ãªãƒ—ãƒ­ã‚»ã‚¹ã§ã™ã€‚å®šæœŸçš„ãªè„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³ã€ä¾å­˜é–¢ä¿‚æ›´æ–°ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ‘ãƒƒãƒé©ç”¨ã‚’å®Ÿæ–½ã—ã¦ãã ã•ã„ã€‚å˜ä¸€ãƒ¦ãƒ¼ã‚¶ãƒ¼ç’°å¢ƒã§ã‚‚åŸºæœ¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã¯å¿…é ˆã§ã™ã€‚